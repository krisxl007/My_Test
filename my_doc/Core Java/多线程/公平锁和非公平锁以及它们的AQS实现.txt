公平锁：每个线程抢占锁的顺序为先后调用lock方法的顺序依次获取锁。效率低，因为每次获取锁都需要CPU切换到第一个排队的线程来获取锁。
非公平锁：每个线程抢占锁的顺序不定，谁运气好，谁就获取到锁，和调用lock方法的先后顺序无关。效率高，因为不需要CPU切换到排队线程获取锁。

JDK中的AQS(AbstractQueuedSynchronizer):基于AQS的锁(比如ReentrantLock)原理大体是这样:

1.有一个state变量，初始值为0，假设当前线程为A,每当A获取一次锁，status++. 释放一次，status--.锁会记录当前持有的线程。
2.当A线程拥有锁的时候，status>0, B线程尝试获取锁的时候会对这个status有一个CAS(0,1)的操作，尝试几次失败后就挂起线程，进入一个等待队列。
3.如果A线程运行完毕后释放锁，此时status==0, A线程会去唤醒等待队列中第一个线程(即A的下一个线程)，即刚刚进入等待队列的B线程，B线程被唤醒
  之后回去检查这个status的值，尝试CAS(0,1)。
  
而如果这时恰好C线程也尝试去争抢这把锁，此时有以下两种实现:

非公平锁实现：C直接尝试对这个status CAS(0,1)操作，并成功改变了status的值，B线程获取锁失败，再次挂起，这就是非公平锁，B在C之前尝试获取锁,而最终是C抢到了锁。
公平锁实现：C发现有线程在等待队列，直接将自己进入等待队列并挂起,B获取锁
