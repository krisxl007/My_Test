分代收集算法 VS 分区收集算法(G1)

分代收集 
当前主流VM垃圾收集都采用”分代收集”(Generational Collection)算法, 这种算法会根据对象存活周期的不同将内存划分为几块, 如JVM中的 新生代、老年代、永久代. 这样就可以根据各年代特点分别采用最适当的GC算法: 
在新生代: 每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集.
在老年代: 因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记―清理”或“标记―整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存.

分区收集
上面介绍的分代收集算法是将对象的生命周期按长短划分为两个部分, 而分区算法则将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收. 这样做的好处是可以控制一次回收多少个小区间. 
在相同条件下, 堆空间越大, 一次GC耗时就越长, 从而产生的停顿也越长. 为了更好地控制GC产生的停顿时间, 将一块大的内存区域分割为多个小块, 根据目标停顿时间, 每次合理地回收若干个小区间(而不是整个堆), 从而减少一次GC所产生的停顿.


===========================================================================================

分代收集算法：
1.复制算法(copy): 现代商用VM的新生代均采用复制算法。优点是不用考虑内存碎片问题，缺点是需要占用多一块内存空间
2.标记清除(mark sweep): 用于老年代，缺点明显: 1.效率低(需要从Root开始遍历标记) 2.会产生内存碎片问题 优点是因为不需要内存碎片整理所以暂停时间短
3.标记整理(mark compact): 用于老年代, 和标记清除算法的标记步骤一样，但是会进行内存碎片的整理，但是内存整理是无法并发进行的，所以停顿时间也因此变长了

-------------------------------------------
JDK的GC实现:

新生代: 三种实现都采用复制算法
1.Serial: 单线程，Stop The World
2.Parallel New：多线程的Serial,也是VM启用CMS收集器-XX: +UseConcMarkSweepGC的默认新生代收集器
3.Parallel Scavenge：JDK的默认GC，与ParNew类似，但与其他收集器关注尽可能缩短垃圾收集时间不同, Parallel Scavenge更关注系统吞吐量，高吞吐量适用于后台运算而不需要太多交互的系统

老年代: 可以采用标记-清除和标记-整理两种算法
1.Serial Old(Mark Sweep)：Serial Old是Serial收集器的老年代版本, 同样是单线程收集器,使用“标记-整理”算法
2.Parallel Old(Mark Compact): 是Parallel Scavenge收老年代版本, 使用多线程和“标记－整理”算法, 吞吐量优先, 主要与Parallel Scavenge配合在注重吞吐量及CPU资源敏感系统
3.CMS(Concurent Mark Sweep): 并发的标记清除算法，停顿时间短，也可以设置参数来进行内存整理

============================================================================================

分区收集算法(G1)

G1的新生代收集特点如下: 
1.一整块堆内存被分为多个Regions.
2.存活对象被拷贝到新的Survivor区或老年代.
3.年轻代内存由一组不连续的heap区组成, 这种方法使得可以动态调整各代区域尺寸.
4.Young GCs会有STW事件, 进行时所有应用程序线程都会被暂停.
5.多线程并发GC.

G1老年代GC特点如下: 
1.并发标记阶段(index 3) 
2.在与应用程序并发执行的过程中会计算活跃度信息.
3.这些活跃度信息标识出那些regions最适合在STW期间回收(which regions will be best to reclaim during an evacuation pause).
4.不像CMS有清理阶段.
5.再次标记阶段(index 4) 
6.使用Snapshot-at-the-Beginning(SATB)算法比CMS快得多.
7.空region直接被回收.
8.拷贝/清理阶段(Copying/Cleanup Phase) 
9.年轻代与老年代同时回收.
10.老年代内存回收会基于他的活跃度信息.

============================================================================================

总结该用什么GC:
1.单核CPU的系统可以用Serial，效率更高
2.多核对吞吐量大，可以接收较长暂停时间的系统可以用Parallel Scavenge + Parallel Old(Mark Compact)
3.多核对交互频繁并且需要较少暂停时间的系统用CMS
4.多核大heap size,对吞吐量和暂停时间均衡的用G1

============================================================================================

